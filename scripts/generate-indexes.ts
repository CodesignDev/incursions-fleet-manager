import * as fs from 'fs'
import {basename, join as combinePath, resolve as resolvePath} from 'path/posix'
import camelCase, {Options as CamelCaseOptions} from 'camelcase'
import minimist from 'minimist'

type DirectoryOptions = CamelCaseOptions & {
    detectDefaultExport?: boolean
    exportAll?: boolean
    targetFile?: string
    insertIntoTargetFile?: boolean
    skipCaseConversion?: boolean
}
type DirectoryOptionList = Record<string, DirectoryOptions>

const argv = minimist(process.argv.slice(2))

const rootDirectory = argv['cwd'] || argv['_'][0]

const directories = ['types', 'utils']
const directoryOptions: DirectoryOptionList = {
    'Hooks': { pascalCase: false },
    'Links': { insertIntoTargetFile: true },
    'styles': { detectDefaultExport: false, exportAll: true },
    'types': {
        detectDefaultExport: false,
        exportAll: true,
        targetFile: 'index.d.ts',
        insertIntoTargetFile: true,
    },
    'utils': { insertIntoTargetFile: true, skipCaseConversion: true },
    '_default': {
        detectDefaultExport: true,
        exportAll: false,
        insertIntoTargetFile: false,
        skipCaseConversion: false,

        pascalCase: true,
        preserveConsecutiveUppercase: true,
    }
}

const includedFiles: string[] = []
const excludedFiles: string[] = ['global.d.ts', 'vite-env.d.ts']

const includedFilesRegex = /\.tsx?$/
const excludedFilesRegex = ''

const removeFileExtensionRegex = /(\.d)?\.tsx?$/i

const defaultExportRegex = /^export default (function|const|[a-zA-Z]*)/

const importStartComment = '// Index list: START - Automatically generated - DO NOT REMOVE'
const importEndComment = '// Index list: END - Automatically generated - DO NOT REMOVE'

const defaultTargetFile = 'index.ts'

const fileHeader = `/**
 * This file is automatically generated.
 *
 * To generate an updated version, run 'npm run generate-indexes'
 *
 * If you register a directory with this script, it can be referenced easier.
 *
 * Instead of:
 *   import Component1 from '@/Components/Component1'
 *   import Component2 from '@/Components/Component2'
 *   import Component3 form '@/Components/Component3'
 *
 * You can use:
 *   import { Component1, Component2 } from '@/Components'
 */`

// This comment is to prevent eslint from flagging the file when there is only a single export
const eslintComment = "// eslint-disable-next-line import/prefer-default-export"

function getDirectoryOptions(directory: string): DirectoryOptions {
    const defaultOptions = directoryOptions['_default']
    const directorySpecificOptions = directoryOptions[directory] || {}

    return {
        ...defaultOptions,
        ...directorySpecificOptions,
    }
}

function createExportTemplate(
    filename: string,
    maybeVariableNameOrOptions?: string | DirectoryOptions,
    maybeOptionsOrExportAsDefault?: DirectoryOptions | boolean,
    maybeExportAsDefault?: boolean
): string {
    if (!filename) return ''

    let variableName: string
    let options: DirectoryOptions
    let exportAsDefaultExport = maybeExportAsDefault || false

    // Flip the relevant arguments
    if (typeof maybeOptionsOrExportAsDefault !== 'object') {
        exportAsDefaultExport = maybeOptionsOrExportAsDefault || false
        options = {}
    } else {
        options = maybeOptionsOrExportAsDefault
    }

    if (typeof maybeVariableNameOrOptions !== 'string') {
        options = maybeVariableNameOrOptions || {}
        variableName = ''
    } else {
        variableName = maybeVariableNameOrOptions
    }

    // Pull out the relevant options
    const { detectDefaultExport = true, exportAll = false, skipCaseConversion = false, ...camelCaseOptions } = options

    // Get the variable
    const variable = skipCaseConversion
        ? variableName || filename
        : camelCase(variableName || filename, camelCaseOptions)

    // Create the export and return it
    let fileExport = `{ default as ${variable} }`
    if (exportAll || !exportAsDefaultExport) {
        fileExport = '*'
    }

    return `export ${fileExport} from './${filename}'`
}

function generateImportsIndex(directory: string, targetFile: string, options: DirectoryOptions): string {
    const directoryPath = resolvePath(directory)
    if (!fs.existsSync(directoryPath)) {
        return ''
    }

    const directoryContents = fs.readdirSync(directoryPath)
    const directoryName = basename(directory)

    const { exportAll = false, insertIntoTargetFile = false } = options

    // Get the list of valid files
    const fileList = directoryContents
        .filter((file) => !isDirectory(directory, file))
        .filter((file) => isValidFile(file, targetFile))

    // If the directory has no files, skip generating any imports
    if (fileList.length < 1) {
        return 'export {}'
    }

    // Process each of the files
    const processedFiles = fileList
        .map((file) => processFile(file, directoryName, options))

    // Include the eslint comment if required
    const includeEslintComment = processedFiles.length === 1 &&
        !insertIntoTargetFile &&
        !processedFiles.some((file) => file?.includes('*') || false)
    if (includeEslintComment) {
        processedFiles.unshift(eslintComment)
    }

    return processedFiles
        .filter((item) => item)
        .join('\n')
}

function isDirectory(baseDirectory: string, path: string): boolean {
    return fs.lstatSync(resolvePath(baseDirectory, path)).isDirectory()
}

function processFile(filename: string, directory: string, options: DirectoryOptions): string | null {
    const { detectDefaultExport = true, targetFile = defaultTargetFile } = options

    // Skip the file if is the target file
    if (!isValidFile(filename, targetFile)) return null

    let file = filename

    // Check to see if the file extension needs stripping
    if (removeFileExtensionRegex && filename.match(removeFileExtensionRegex)) {
        file = filename.replace(removeFileExtensionRegex, '')
    }

    // Create the export template for the file
    const hasDefaultExport = detectDefaultExport ? fileHasDefaultExport(filename, directory) : true
    return createExportTemplate(file, options, hasDefaultExport)
}

function isValidFile(filename: string, indexFile: string): boolean {
    // Explicitly skip the index file
    if (indexFile && filename.localeCompare(indexFile) === 0) return false

    // Remove any files that match the excluded files list / regex
    if (excludedFiles && excludedFiles.includes(filename)) return false
    if (excludedFilesRegex && filename.match(excludedFilesRegex)) return false

    // Allow any files on the list of included files / regex
    if (includedFiles && includedFiles.includes(filename)) return true
    if (includedFilesRegex && filename.match(includedFilesRegex)) return true

    // Default is to return false
    return false
}

function readFileContents(filePath: string) {
    return fs.readFileSync(filePath, { encoding: 'utf-8', flag: 'r' })
}

function fileHasDefaultExport(filename: string, directory: string) {
    // Read the contents of the file being checked as lines
    const directoryPath = resolvePath(rootDirectory, directory)
    const file = readFileContents(combinePath(directoryPath, filename))
    const lines = file.split(/\r?\n/)

    // Check to see if there is at least one line that matches the default export format
    return lines.some((line) => line.match(defaultExportRegex))
}

directories.forEach((directory) => {
    const directoryPath = resolvePath(rootDirectory, directory)
    const directoryName = basename(directoryPath)

    // Get the options for the current directory
    const options = getDirectoryOptions(directoryName)
    const { targetFile = defaultTargetFile, insertIntoTargetFile = false } = options

    // Generate the imports required
    const indexContents = generateImportsIndex(directoryPath, targetFile, options)
    if (indexContents === '') return

    // Include the file header if required
    const fileContents = insertIntoTargetFile ? indexContents : `${fileHeader}\n\n${indexContents}`

    // Does the target file exist
    const targetFilePath = resolvePath(directoryPath, targetFile)
    const targetFileExists = fs.existsSync(targetFilePath)

    // If this is being inserted into an existing index.ts file, perform some extra logic
    if (insertIntoTargetFile) {
        let currentFileContents = ''
        let replacedFileContents = false

        // If the file exists, read the contents to be replaced
        if (targetFileExists) {
            currentFileContents = readFileContents(targetFilePath)

            // Check to see if the list of imports already exist
            const re = new RegExp(`${importStartComment}\\n((.|\\n)*)\\n${importEndComment}`, 'g')
            if (currentFileContents.match(re)) {

                // Replace the existing imports with the new ones
                currentFileContents = currentFileContents.replace(re, (match, matchedContents) => {
                    return match.replace(matchedContents, fileContents)
                })
                replacedFileContents = true
            }
        }

        // If the contents have not replaced, add the imports to the top of the file
        if (!replacedFileContents) {
            let contentsToInsert = `${importStartComment}\n${fileContents}\n${importEndComment}\n`
            if (currentFileContents !== '') {
                contentsToInsert += `\n${currentFileContents}`
            }

            currentFileContents = contentsToInsert
        }

        fs.writeFileSync(targetFilePath, currentFileContents)
        return
    }

    // Otherwise create the file
    fs.writeFileSync(targetFilePath, fileContents + '\n')
})
